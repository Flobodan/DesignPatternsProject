<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Design Patterns Introduction</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/prism.css" rel="stylesheet"/>
        <link href="css/styles.css" rel="stylesheet" />
        <script type="text/javascript" src="./quiz/quiz.js"></script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
            <div class="container px-4">
                <a class="navbar-brand" href="#page-top">Design Patterns</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item"><a class="nav-link" href="#introduction">Introduction</a></li>
                        <li class="nav-item"><a class="nav-link" href="#singleton">Singleton</a></li>
                        <li class="nav-item"><a class="nav-link" href="#observer">Observer</a></li>
                        <li class="nav-item"><a class="nav-link" href="#mvc">MVC</a></li>
                        <li class="nav-item"><a class="nav-link" href="#mvvm">MVVM</a></li>
                        <li class="nav-item"><a class="nav-link" href="#exercises">Exercises</a></li>
                    </ul>
                </div>
                <a class="btn btn-outline-info" href="index.html">
                    üá©üá™ German
                </a>
            </div>
        </nav>
        <!-- Header-->
        <header class="text-white" style="background: rgb(2,0,36); background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);">
            <div class="container px-4 text-center">
                <h1 class="fw-bolder">Design Patterns</h1>
                <p class="lead">Introduction in Singleton, Oberserver and MVC pattern</p>
            </div>    
        </header>




        <!-- Einf√ºhrung section-->
        <section id="introduction">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h3>What are design patterns?</h3>
                        <p class="lead">
                            Design patterns offer <strong>sample solutions for recurring problems!</strong>
                            <br>
                            They designate design patterns, i.e. structures, models, templates and patterns that can be used as models in the development of stable software.
                        </p>
                    </div>
                    <div class="col-lg-8" style="padding-top: 5%;">
                        <h3>What is a pattern?</h3>
                        <p class="lead">
                            A pattern is a formal documentation in form for the model-like solution of a certain problem.
                            <br>
                            For this purpose, design patterns are not invented, but are derived from repeated application from successful practice.
                        </p>
                    </div>
                    <div class="col-lg-8" style="padding-top: 5%;">
                        <h3>Architecture patterns as a basis for modern software design!</h3>
                        <p class="lead">
                            Originally, patterns originated in the engineering field of architecture.
                            <br>
                            Even if these models relate to building architecture and urban planning, fundamental principles and insights can be transferred to disciplines such as software architectures and software development.
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- Singleton section-->
        <section class="bg-light" id="singleton">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">

                    <div class="col-lg-8">
                        <h2>Singleton</h2>
                        <div class="text-center">
                            <img src="assets/umlSingleton.png"/>
                        </div>
                        <p class="lead">
                            The Singleton design pattern is used when only one instance of an object may exist. Two types of singleton creation can be distinguished. The first possibility is a so-called lazy singleton. This means that the instance is only created when it is really needed.
                        </p>
                        <pre>
                            <code class="language-java">
public final class Singleton {

    private static Singleton instanz;
    
    private Singleton() {}
    
    public synchronized static Singleton getInstanz() {
        if(instanz==null)
            instanz = new Singleton();
        return instanz;
    }
}                           </code>
                        </pre>
                        <br>
                        <p class="lead">
                            During initialization, only the memory area for the instance is reserved. The private constructor has no function here. But by the fact that it is declared as private, it is prevented that from the outside further instances can be created. Only with the first call of "`getInstanz"' the instance is created and returned. With each further call the already created instance is returned. When using a lazy singleton, care must be taken to avoid problems with concurrency caused by multiple threads. Therefore it is necessary to declare the "`getInstance"' method as "`synchronized"'. To get around this problem one can use an Eager Singleton.
                        </p>
                        <pre>
                            <code class="language-java">
final class EagerSingleton{

    private final static EagerSingleton instanz = 
        new EagerSingleton();
    
    private EagerSingleton() {}
    
    public static EagerSingleton getInstanz() {
        return instanz;
    }
}                           </code>
                        </pre>

                    <!-- Pros and cons section-->
                    <br>
                    <hr>
                    <br>
                    <div>
                        <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;">
                            <p class="lead text-center">
                                <strong>Advantages:</strong>
                            </p>
                            <p>
                                <strong>Access control:</strong> The singleton encapsulates its own creation and can thus control exactly when and how access to the singleton is allowed.
                                <br>
                                <br>
                                <strong>Clean namespace:</strong> The namespace is not overloaded with countless global variables, but provided encapsulated in a singleton.<br>
                                <br>
                                <strong>Specialization:</strong> A singleton can be derived to assign new functionality to it. Integration into existing code is simple. Which subclass is to be used can be decided dynamically at runtime.
                            </p>
                            <br>
                        </div>
                        <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;">
                            <p class="lead text-center">
                                <strong>Disadvantages:</strong>
                            </p>
                            <p>
                                <strong>Procedural programming:</strong> The extensive use of singletons leads to a similar unfavorable condition as with global variables. This corresponds to procedural programming and has nothing to do with object orientation and encapsulation
                                A singleton can be derived to assign new functionality to it. Integration into existing code is simple. Which subclass is to be used can be decided dynamically at runtime.
                                <br>
                                <br>
                                <strong>Intransparency:</strong> 
                                Whether a class uses a singleton is not clear from its interface, but from its implementation. This is hard-coupled to the Singleton. The definition of the interface alone can no longer be relied upon, since the implementation has unspecified dependencies.
                                <br>
                                <br>
                                <strong>Clarity, maintainability and reusability suffer enormously!</strong>
                                <br>
                                When changes are made to the singleton, it is not clear which parts of the program are affected. Malfunctions can be traced back with difficulty.
                            </p>
                            <br>
                        </div>
                    </div>

                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- Observer section-->
        <section id="observer">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Observer Pattern</h2>
                        <div class="text-center">
                            <img src="assets/umlObserver.jpg" />
                        </div>
                        <p class="lead">
                            <p>
                                Das Haupteinsatzgebiet von einem Observer Pattern ist die Gestaltung von Grafischen Oberfl√§chen.
                                Das Observer Pattern sorgt zum Beispiel daf√ºr, dass die Elemente einer Grafische Oberfl√§che, die eine identische Datenquelle verwenden, sich aktualisieren, sobald sich die Quelldaten √§ndern.  
                                Programme, die das Observer Pattern verwenden, werden in zwei Teile aufgeteilt.
                                </p>
                                <p>
                                Einmal die Subject-Klasse, welche die Daten enth√§lt und zum anderen die Observer-Klassen und die Observer-Schnittstelle, welche die Daten einlesen und anzeigen, ausgeben oder weiterverarbeiten. 
                                Die obere Abbildung zeigt die Struktur dieses Patterns. 
                                </p>
                                <p>
                                Im folgenden Quellcode sieht man ein Beispiel f√ºr ein Programm, welches das Observer Pattern verwendet:
                                </p>


                                <pre>
                            <code class="language-java">
import java.util.ArrayList;

/*
    * Hier wird das sogenannte Observerpattern vorgestellt.
    * Dieses dient zur Verwaltung von verschiedenen Observern,
    * welche auf die selben Daten zugreifen.
    */

/*
    * Dieses Interface stellt den anderen Observern
    * die refresh Methode zur Verf√ºgung. Jeder Observer
    * muss diese Methode implementieren. In der Implementierung
    * der refresh Methode kann jeder Observer mit Daten des
    * Subjects arbeiten. Immer wenn diese sich √§ndern sollte
    * refresh aufgerufen werden.
    */
interface Observer{
/*
    * Muss von allen Observern 
    * implementiert werden
    */
public void refresh();
}


/*
    * Dies ist ein Observer.
    * Dieser implementiert die Schnittstelle Observer und
    * garantiert dadurch, dass die Refreshmethode implementiert ist.
    * Er wartet auf refreshs von dem Subject um zu reagieren.
    */
class RealObserver1 implements Observer{
//Bezeichnung des Observers
private int id;

//Referenz auf das Subject
private Subject subject;

//Konstruktor
public RealObserver1(int id, Subject subject){
    this.id = id;
    this.subject = subject;
}

//So reagiert der Observer bei einem Notify
public void refresh(){
    System.out.println(
        "RealObserver 1 with id " + id + 
        " refreshed. Current value is " + 
        subject.getValue());
}
}

/*
    * Dies ist eine zweite Observerklasse.
    * Dieser implementiert die Schnittstelle Observer und
    * garantiert dadurch, dass die Refreshmethode implementiert ist.
    * Er wartet auf refreshs von dem Subject um zu reagieren.
    */
class RealObserver2 implements Observer{
//Bezeichnung des Observers
private int id;

//Referenz auf das Subject
private Subject subject;

//Konstruktor
public RealObserver2(int id, Subject subject){
    this.id = id;
    this.subject = subject;
}

//So reagiert der Observer bei einem Notify
public void refresh(){
    System.out.println(
        "RealObserver 2 with id " + id + 
        " refreshed. Current value is " + 
        subject.getValue());
}
}

/*
    * In der Subjectklasse werden alle Observer in
    * einem Array, einer ArrayList oder einer √§hnlichen
    * Datenstruktur gespeichert.
    * Falls sich etwas an den Daten √§ndert (hier: curValue)
    * werden alle Observer benachrichtigt.
    */
class Subject{
//Liste mit allen Observern
private ArrayList observer;

//Die zu verwaltenden Daten
private int curValue;

//Konstruktor
public Subject(){
    observer = new ArrayList();
    curValue = 0;
}

//F√ºgt einen Observer ein und benachrichtigt diesen
public void addObserver(Observer o){
    observer.add(o);
    o.refresh();
}

//Entfernt einen Observer
public void removeObserver(Observer o){
    observer.remove(o);
}

//Benachrichtigt alle Observer
public void notifyObserver(){
    for(Observer o : observer){
        o.refresh();
    }
}

//Inkrementiert die Daten
public void incValue(){
    curValue++;
    notifyObserver();
}

//Gibt die Daten zur√ºck
public int getValue(){
    return curValue;
}
}

/*
    * Es werden ein Subject und vier Observer erstellt.
    * Nachdem die Observer bei dem Subject angemeldet wurden,
    * wird der curValue einige male inkrementiert.
    */
public class ObserverPattern {
public static void main(String[] args){
    //Erstellen des Subjects
    Subject subject = new Subject();
    
    //Erstellen der Observer
    RealObserver1 ro1a = new RealObserver1(1,subject);
    RealObserver1 ro1b = new RealObserver1(2,subject);
    RealObserver2 ro2a = new RealObserver2(3,subject);
    RealObserver2 ro2b = new RealObserver2(4,subject);
    
    //Anmelden der Observer
    subject.addObserver(ro1a);
    subject.addObserver(ro1b);
    subject.addObserver(ro2a);
    subject.addObserver(ro2b);
    
    //Mehrfaches inkrementieren der Daten
    subject.incValue();
    subject.incValue();
    subject.incValue();
}
}
                            </code>
                        </pre>
                        <p>
                            Dort gibt es ein Interface Observer, welches von den beiden Observer-Klassen RealObserver1 und RealObserver2 implementiert werden muss. </p>
                            <p>
                            Das Interface enth√§lt eine Funktion refresh() mit der alle Observer-Klassen benachrichtigt werden, wenn sich Daten in der Subject-Klasse ge√§ndert haben. 
                            Dies geschieht in dem sich alle Observer-Klassen bei der Subject-Klasse in eine ArrayList (oder eine beliebige andere Struktur) eintragen. </p>
                            <p>
                            Wenn sich nun Daten √§ndern ruft die Subject-Klasse die Methode notifyObserver() auf, in welcher alle Observer-Klassen durchlaufen werden und deren refresh() Methode aufgerufen wird. 
                            In dieser Methode k√∂nnen dann die Observer-Klassen auf die Daten√§nderungen reagieren. </p>
                            <p>
                            Das Eintragen und Austragen der Observer-Klassen bei der Subject-Klasse geschieht √ºber die Methoden addObserver(Observer) und removeObserver(Observer). 
                        </p>
                            <p>
                            Wie man sieht, bietet das Observer Pattern eine praktische Methode, mit welcher man daf√ºr sorgen kann, dass bei Daten√§nderungen in einem Programm andere Programmteile sofort aktualisiert und an die neuen Daten angepasst werden k√∂nnen.</p>
                            </p>
                        <!-- Pros and cons section-->
                        <br>
                        <hr>
                        <br>
                        <div>
                            <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;">
                                <p class="lead text-center">
                                    <strong>Vorteile:</strong>
                                    <p>
                                        <strong>Zustandskonsistenz:</strong>
                                        Die Daten im Gesamtsystem bleiben konsistent, da die Observer ihren Zustand automatisch bei √Ñnderung des Subjects anpassen. Weiterhin bleibt der Informationsaustausch bzw. die Kopplung zwischen den Objekten auf die Zeit zwischen An- und Abmelden des Observers am Subject begrenzt.
                                        <br>
                                        <br>
                                        <strong>Flexibilit√§t und Modularit√§t:</strong>
                                        Das System erlaubt es, dass mehrere verschiedene Observer ein einziges Subject beobachten, aber auch dass ein Observer mehrere Subjects beobachtet. Weiterhin k√∂nnen Klassen sowohl Observer als auch Subject in einem seien.
                                        <br>
                                        <br>
                                        <strong>Wiederverwendbarkeit:</strong>
                                        Durch das Observer Pattern lassen sich Subject und Observer unabh√§ngig voneinander variieren. Somit kann das Subject wiederverwendet werden, ohne seine abh√§ngigen Observer verwenden zu m√ºssen und umgekehrt. Ebenso sind bestehende Subjects wiederverwendbar, wenn neue Observer hinzugef√ºgt werden.

                                    </p>
                                </p>
                                <br>
                            </div>
                            <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;">
                                <p class="lead text-center">
                                    <strong>Nachteile:</strong>
                                    <p>
                                        <strong>Aktualisierungskaskaden und -zyklen:</strong>
                                        Bei umfangreichen Systemen mit vielen Subjects und Observer kann es schnell zu ganzen Aktualisierungskaskaden kommen, da die Observer nichts von einander wissen und nicht absch√§tzen k√∂nnen, welche Folgen eine einzige Modifikation an einem Subject hat.
                                        <br>
                                        <br>
                                        <strong>Abmeldung von Observer:</strong>
                                        Schnell vergisst man ein Observer beim Subject abzumelden, wenn man es nicht mehr braucht. Dies kann in F√§llen von Mehrfachanmeldung (Mehrfachbenachrichtigung) merkw√ºrdige Effekte zur Folge haben und verhindert die automatische Speicherfreisetzung (Garbage Collection in Java und C#), da das Subject immer noch eine Referenz auf ein nicht mehr gebrauchtes Objekt h√§lt.
                                    </p>
                                </p>
                                <br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- MVC section-->
        <section id="mvc">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>MVC Pattern</h2>
                        <div class="text-center">
                            <img src="assets/umlMVC.jpg" />
                        </div>
                        <p class="lead">
                            <p><b>MVC</b> steht f√ºr <b>M</b>odel-<b>V</b>iew-<b>C</b>ontrol.</p>

                            <p>Mit dem MVC Pattern, wird ein Programm in drei unterschiedliche Teile aufgeteilt. Dabei beinhaltet der Model-Teil die Daten bzw. Den Zugriff auf diese. Dies ist auch der Teil, on dem sich der klassische, objektorientierte Teil des Programms vorhanden sein wird. Das bedeutet auch den Datenbankzugriff oder jede andere Art von Datenverwaltung. Des Weiteren gibt es noch den View-Abschnitt. Hier befinden sich alle Ansichten. Diese zeigen normalerweise die Daten des Models an, sind jedoch komplett unabh√§ngig von den Daten implementiert. Als letzten und dritten Teil des Patterns folgt der Control-Teil. Dieser beinhaltet alle Kontrollm√∂glichkeiten, mit welchen ein Benutzer das Programm steuern kann. Wichtig: auch dieser Teil ist normalerweise komplett unabh√§ngig von den anderen Teilen.</p>

                            <p>Die drei verschiedenen Teile des MVC wissen ausschlie√ülich durch Referenzen voneinander und nur durch die definierten Zugriffsmethoden wird eine Kommunikation gew√§hrleistet. Es soll also beispielsweise nicht m√∂glich sein von einer View-Klasse direkt auf Objekte der Model-Klasse zuzugreifen.</p>

                            <p>Im folgenden Beispiel wird ein Programm vorgestellt, welches nicht nur ein MVC-Entwurfsmuster implementiert, sondern gleichzeitig auch noch ein Observer-Pattern verwendet. Diese Vermischung der beiden Entwurfsmuster kommt sehr h√§ufig vor, da sie gut zusammenpassen. Dabei sind die beiden so verkn√ºpft, dass es sich bei den View-Klassen um die Observerklassen des Observer-Patterns handelt und die Model-Klasse die Subject-Klasse des Patterns repr√§sentiert.</p>
                        </p>
                        <pre>
                            <code class="language-java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

interface View{
    //Muss von allen Views implementiert werden
    public void refresh();
}

class RealView extends JFrame implements View{
    //Id des Fensters
    private int id;
    
    //Referenz auf das Model
    private Model model;
    
    //JTextField des Fensters
    private JTextField txt;
    
    //Konstruktor
    public RealView(int id, Model model){
        this.id = id;
        this.model = model;
        
        setTitle("View " + id);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        txt = new JTextField("");
        getContentPane().add(txt);
        
        refresh();
        
        setLocation(250, 60 * id);
        pack();
        setVisible(true);
    }
    
    /*
        * Wird ausgef√ºhrt, wenn sich etwas an den
        * Daten im Model √§ndert
        */
    public void refresh(){
        txt.setText(
            "View " + id + ": " + 
            model.getValue());
    }
}

class ButtonView extends JFrame{	
    public ButtonView(Model model){		
        //Stellt die Eigenschaften des Fensters ein
        setTitle("ButtonView");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        //F√ºgt die Controlklasse zu dem Button hinzu
        JButton btn = new JButton("Increment");
        btn.addActionListener(new Control(model));
        getContentPane().add(btn);
        
        //Zeigt das Fenster an
        setLocation(100,100);
        pack();
        setVisible(true);		
    }
}

class Control implements ActionListener{
    //Referenz auf das Model
    private Model model;
    
    //Konstruktor
    public Control(Model model){
        this.model = model;
    }
    
    //Wird ausgef√ºhrt, wenn man den Button anklickt
    public void actionPerformed(ActionEvent evt){
        model.incValue();
    }
}

class Model{
    //Alle angemeldeten Views
    private ArrayList views;
    
    //Daten
    private int curValue;
    
    //Konstruktor
    public Model(){
        views = new ArrayList();
        curValue = 0;
    }
    
    //F√ºgt eine neue View hinzu
    public void addView(View view){
        views.add(view);
        view.refresh();
    }
    
    //Entfernt eine View
    public void removeView(View view){
        views.remove(view);
    }
    
    //Benachrichtigt alle Views
    public void notifyViews(){
        for(View v : views){
            v.refresh();
        }
    }
    
    //Inkrementiert die Daten
    public void incValue(){
        curValue++;
        notifyViews();
    }
    
    //Gibt die Daten zur√ºck
    public int getValue(){
        return curValue;
    }
}

public class MVCPattern {
    public static void main(String[] args){
        /*
            * Erstellt das Model, in welchem die Daten,
            * sowie die Views verwaltet werden.
            */
        Model model = new Model();
        
        //Die Views, welche die Daten anzeigen
        RealView view1 = new RealView(1, model);
        RealView view2 = new RealView(2, model);
        
        //Die Views tragen sich bei dem Model ein
        model.addView(view1);
        model.addView(view2);
        
        //Die View zur Bedienung des Programms
        new ButtonView(model);
    }
}
                            </code>
                        </pre>

                        <!-- Pros and cons section-->
                        <br>
                        <hr>
                        <br>
                        <div>
                            <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                                <p class="lead text-center">
                                    <strong>Vorteile:</strong>
                                    <p>
                                        Der Vorteil der Aufgabenverteilung einer Model View Controller Architektur ist zum einen die Aufteilung in logische, unabh√§ngige Klassen. Damit erm√∂glicht eine Model View Controller Architektur agile Entwicklung, denn es besteht jederzeit die Option, jede der drei Komponenten auszutauschen.
                                        <br>
                                        <br>
                                        Vorteile findet man zum einen in der M√∂glichkeit, dass ein und dasselbe Datenmodell in mehreren Ansichten repr√§sentiert werden kann. Des weiteren sind alle Ansichten die sich auf ein Modell Beziehen automatisch synchronisiert und es k√∂nnen Bedienelemente beliebig vertauscht werden. Au√üerdem ist es ohne weiteres m√∂glich auf eine vorhandenes Model eine neue View zu implementieren. Dadurch ist ein solches System nahezu beliebig skalierbar.
                                    </p>
                                </p>
                                <br>
                            </div>
                            <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                                <p class="lead text-center">
                                    <strong>Nachteile:</strong>
                                    <p>
                                        Ein Nachteil besteht darin, dass der Zugriff mehrerer Views auf ein Model schnell zu einer hohen Komplexit√§t f√ºhren kann und sich dadurch fehlerhafte Stellen im Programm schwerer ausfindig machen lassen. Des weitern kann man teilweise von einem ineffizienten Datenzugriff innerhalb einer Ansicht sprechen, da immer noch ein Objekt dazwischen geschaltet ist. Au√üerdem ist dass MVC-Konzept schwierig in WYSIWYG-Werkzeuge zu integrieren. Auch die starke Koppelung zwischen Modell und Sicht sowie zwischen Modell und Controller kann als Nachteil interpretiert werden.
                                    </p>
                                </p>
                                <br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            margin-top: 10%;
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>
        
<!-- MVVM section-->
<section id="mvvm">
    <div class="container px-4">
        <div class="row gx-4 justify-content-center">
            <div class="col-lg-8">
                <h2>MVVM Pattern</h2>
                <div class="text-center">
                    <img src="assets/uml_mvvm.png" />
                </div>
                <p class="lead">
                    <p><b>MVVM</b> steht f√ºr <b>M</b>odel-<b>V</b>iew-<b>V</b>iew<b>M</b>odel</p>

Grundidee ist die Aufteilung des Codes in einen allgemeinen, oberfl√§chenunabh√§ngigen Teil (das Model) und auf der anderen Seite den oberfl√§chenspezifischen Code. Dieser kann wiederum in Code zur reinen Anzeige (die View) und Code zur Verarbeitung von Benutzereingaben und Steuerung der Oberfl√§che (der Controller) geteilt werden.
‚Äã
  <br>  
Die Idee von MVVM ist es, den gesamten UI-Zustand im sogenannten "ViewModel" abzubilden. Dieses ViewModel enth√§lt also beispielsweise Felder f√ºr die aktuellen Werte von Textfeldern, Tabellen und anderen Komponenten. Au√üerdem werden Informationen wie "Button X ist inaktiv" ebenfalls als Boolean-Feld im ViewModel hinterlegt.
<br> Die View pr√§sentiert lediglich den UI-Zustand des ViewModels. Wird der UI-Zustand vom Nutzer ver√§ndert, z. B. indem in einem Textfeld getippt wird, reicht die View diese √Ñnderungen umgehend an das ViewModel weiter. Andersherum m√ºssen aber auch √Ñnderungen, die vom ViewModel ausgehen, umgehend von der View angezeigt werden. 
<br>View und ViewModel m√ºssen also stets synchron gehalten werden. Wie diese Synchronisierung konkret umgesetzt wird, kommt dabei auf die Programmiersprache bzw. das Framework an.

                </p>
                <pre>
                    <code class="language-java">

                    </code>
                </pre>

                <!-- Pros and cons section-->
                <br>
                <hr>
                <br>
                <h1 class="text-center">MVC vs MVVM</h1>
                <table class="table table-bordered">
                    <thead>
                      <tr>
                        <th scope="col">MVC</th>
                        <th scope="col">MVVM</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Controller-Klasse dient als Einstiegspunkt f√ºr die Anwendung.</td>
                        <td>Die View-Klasse dient als EInstiegspunkt f√ºr die Anwendung.</td>
                      </tr>
                      <tr>
                        <td>‚ÄúOne to Many‚Äù-Beziehungen zwischen Controler und View. </td>
                        <td>‚ÄúOne to Many‚Äù-Beziehungen zwischen View und View-Model. </td>
                      </tr>
                      <tr>
                        <td>View referenziert nicht den Controller.</td>
                        <td>View referenziert die View-Model.</td>
                      </tr>
                      <tr>
                        <td>MVC ist ein altes Konzept.</td>
                        <td>MVVM ist ein relativ neues Konzept.</td>
                      </tr>
                      <tr>
                        <td>Niedrige Lesbarkeit, Wartbarkeit und schweirig f√ºr Unit-Tests. </td>
                        <td>Schwierig zu debuggen, wenn viele Data-Bindings verwendet werden.</td>
                      </tr>
                      <tr>
                        <td>MVC Model Komponenten k√∂nnen seperat vom Benutzer getestet werden. </td>
                        <td>Der Code ist Event-driven und leicht f√ºr Unit-Tests zug√§nglich. </td>
                      </tr>
                    </tbody>
                  </table>
                <div>
                    <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                        <p class="lead text-center">
                            <strong>Vorteile:</strong>
                            <p>
                                Durch diese Trennung k√∂nnen die Anwendungsschichten von verschiedenen Arbeitsgruppen entwickelt werden. Designer k√∂nnen einen Fokus auf das Benutzererlebnis und die UI legen (VIEW) und Entwickler unabh√§ngig davon die UI- und Gesch√§ftslogik schreibe (MODEL und VIEWMODEL). In der Regel sind keine aufwendigen UI-Tests n√∂tig. Stattdessen gen√ºgen codebasierte Modul-Tests des ViewModel. Auch ist eine leichtere Austauschbarkeit der View z.B. nach WPF oder Windows Phone m√∂glich. Unterst√ºtzung in WPF, Silverlight, Windows Phone und Windows Store Apps.
                            </p>
                        </p>
                        <br>
                    </div>
                    <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                        <p class="lead text-center">
                            <strong>Nachteile:</strong>
                            <p>
                                MVVM stellt einen Mehraufwand dar und ist f√ºr Anwendungen mit einfacher UI ein Overkill. F√ºr gr√∂√üere Anwendungen kann das Design eines ausreichend allgemeinen ViewModel‚Äôs im Voraus schwierig sein. Au√üerdem f√ºhre eine schlecht verwaltete Datenbindung zu einem erheblichen Speicherbedarf der Anwendung.
                            </p>
                        </p>
                        <br>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

         <!-- √úbung section-->
         <section id="exercises">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Introduction</h2>

                        <!-- Quiz section -->
                        <div class="zuordnungs-quiz" lang="de">
                            <h2 id="zuordnungs-quiz-pattern">Ordne die Eigenschaften zu.</h2>
                            <p>Ordnen Sie folgende Begriffe/Dinge einander zu, indem Sie die gr√ºnen Felder mit der Maus verschieben!</p>
                            <table>
                                <tr>
                                    <td>Singleton</td>
                                    <td>genau eine Instanz</td>
                                    <td>private Konstruktor hat hier keine Funktion</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                </tr>
                                <tr>
                                    <td>MVC</td>
                                    <td>drei Teile</td>
                                    <td>Control-Teil</td>
                                    <td>View</td>
                                    <td>Zugriffsmethoden</td>
                                    <td>&nbsp;</td>
                                </tr>
                                <tr>
                                    <td>Observer</td>
                                    <td>Zwei Teile</td>
                                    <td>Subject-Klasse</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                </tr>
                            </table>
                        </div>
                        
                    </div>
                </div>
            </div>
        </section>
        <!-- Footer-->
        <footer class="py-5 bg-dark">
            <div class="container px-4"><p class="m-0 text-center text-white">Copyright &copy; Dennis, Florian, Michele</p></div>
            <div>Quellen: <a href="https://public.hochschule-trier.de" style="color: rgba(0, 0, 0, .0)">KLICK</a></div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
        <script src="js/prism.js"></script>
    </body>
</html>
