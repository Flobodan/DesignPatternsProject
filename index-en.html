<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Design Patterns Introduction</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/prism.css" rel="stylesheet"/>
        <link href="css/styles.css" rel="stylesheet" />
        <script type="text/javascript" src="./quiz/quiz.js"></script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
            <div class="container px-4">
                <a class="navbar-brand" href="#page-top">Design Patterns</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item"><a class="nav-link" href="#introduction">Introduction</a></li>
                        <li class="nav-item"><a class="nav-link" href="#singleton">Singleton</a></li>
                        <li class="nav-item"><a class="nav-link" href="#observer">Observer</a></li>
                        <li class="nav-item"><a class="nav-link" href="#mvc">MVC</a></li>
                        <li class="nav-item"><a class="nav-link" href="#mvvm">MVVM</a></li>
                        <li class="nav-item"><a class="nav-link" href="#exercises">Exercises</a></li>
                    </ul>
                </div>
                <a class="btn btn-outline-info" href="index.html">
                    🇩🇪 German
                </a>
            </div>
        </nav>
        <!-- Header-->
        <header class="text-white" style="background: rgb(2,0,36); background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);">
            <div class="container px-4 text-center">
                <h1 class="fw-bolder">Design Patterns</h1>
                <p class="lead">Introduction in Singleton, Oberserver and MVC pattern</p>
            </div>    
        </header>




        <!-- Einführung section-->
        <section id="introduction">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h3>What are design patterns?</h3>
                        <p class="lead">
                            Design patterns offer <strong>sample solutions for recurring problems!</strong>
                            <br>
                            They designate design patterns, i.e. structures, models, templates and patterns that can be used as models in the development of stable software.
                        </p>
                    </div>
                    <div class="col-lg-8" style="padding-top: 5%;">
                        <h3>What is a pattern?</h3>
                        <p class="lead">
                            A pattern is a formal documentation in form for the model-like solution of a certain problem.
                            <br>
                            For this purpose, design patterns are not invented, but are derived from repeated application from successful practice.
                        </p>
                    </div>
                    <div class="col-lg-8" style="padding-top: 5%;">
                        <h3>Architecture patterns as a basis for modern software design!</h3>
                        <p class="lead">
                            Originally, patterns originated in the engineering field of architecture.
                            <br>
                            Even if these models relate to building architecture and urban planning, fundamental principles and insights can be transferred to disciplines such as software architectures and software development.
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- Singleton section-->
        <section class="bg-light" id="singleton">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">

                    <div class="col-lg-8">
                        <h2>Singleton</h2>
                        <div class="text-center">
                            <img src="assets/umlSingleton.png"/>
                        </div>
                        <p class="lead">
                            The Singleton design pattern is used when only one instance of an object may exist. Two types of singleton creation can be differentiated. The first possibility is a so-called lazy singleton. This means that the instance is only created when it is really needed.
                        </p>
                        <pre>
                            <code class="language-java">
public final class Singleton {

    private static Singleton instanz;
    
    private Singleton() {}
    
    public synchronized static Singleton getInstanz() {
        if(instanz==null)
            instanz = new Singleton();
        return instanz;
    }
}                           </code>
                        </pre>
                        <br>
                        <p class="lead">
                            During initialization, only the memory area for the instance is reserved. The private constructor has no function here. But by the fact that it is declared as private, it is prevented that from the outside further instances can be created. Only with the first call of "`getInstanz"' the instance is created and returned. With each further call the already created instance is returned. When using a lazy singleton, care must be taken to avoid problems with concurrency caused by multiple threads. Therefore it is necessary to declare the "`getInstance"' method as "`synchronized"'. To get around this problem one can use an Eager Singleton.
                        </p>
                        <pre>
                            <code class="language-java">
final class EagerSingleton{

    private final static EagerSingleton instanz = 
        new EagerSingleton();
    
    private EagerSingleton() {}
    
    public static EagerSingleton getInstanz() {
        return instanz;
    }
}                           </code>
                        </pre>

                    <!-- Pros and cons section-->
                    <br>
                    <hr>
                    <br>
                    <div>
                        <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;">
                            <p class="lead text-center">
                                <strong>Pros:</strong>
                            </p>
                            <p>
                                <strong>Access control:</strong> The singleton encapsulates its own creation and can thus control exactly when and how access to the singleton is allowed.
                                <br>
                                <br>
                                <strong>Clean namespace:</strong> The namespace is not overloaded with countless global variables, but provided encapsulated in a singleton.<br>
                                <br>
                                <strong>Specialization:</strong> A singleton can be derived to assign new functionality to it. Integration into existing code is simple. Which subclass is to be used can be decided dynamically at runtime.
                            </p>
                            <br>
                        </div>
                        <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;">
                            <p class="lead text-center">
                                <strong>Cons:</strong>
                            </p>
                            <p>
                                <strong>Procedural programming:</strong> The extensive use of singletons leads to a similar unfavorable condition as with global variables. This corresponds to procedural programming and has nothing to do with object orientation and encapsulation
                                A singleton can be derived to assign new functionality to it. Integration into existing code is simple. Which subclass is to be used can be decided dynamically at runtime.
                                <br>
                                <br>
                                <strong>Intransparency:</strong> 
                                Whether a class uses a singleton is not clear from its interface, but from its implementation. This is hard-coupled to the Singleton. The definition of the interface alone can no longer be relied upon, since the implementation has unspecified dependencies.
                                <br>
                                <br>
                                <strong>Clarity, maintainability and reusability suffer enormously!</strong>
                                <br>
                                When changes are made to the singleton, it is not clear which parts of the program are affected. Malfunctions can be traced back with difficulty.
                            </p>
                            <br>
                        </div>
                    </div>

                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- Observer section-->
        <section id="observer">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Observer Pattern</h2>
                        <div class="text-center">
                            <img src="assets/umlObserver.jpg" />
                        </div>
                        <p class="lead">
                            <p>
                                The Oberserver pattern is mainly used in the design of graphical user interfaces. As soon as data sources change, it ensures, for example, that a dependent element of a graphical user interface is automatically updated. Programs that use the Observer Pattern are divided into two parts.
                                </p>
                                <p>
                                One is the Subject class, which contains the data, and the other is the Observer classes and the Observer interface, which read and display, output, or process the data. The upper figure shows the structure of this pattern. 
                                </p>
                                <p>
                                In the following source code you can see an example of a program that uses the Observer pattern:
                                </p>


                                <pre>
                            <code class="language-java">
import java.util.ArrayList;

/*
    * Here the so-called Observerpattern is introduced.
    * This serves for the administration of different Observern,
    * which access the same data.
    */

/*
    * This interface makes available to the other observers
    * the refresh method to the other observers. Each observer
    * must implement this method. In the implementation
    * the refresh method, each observer can work with data of the
    * subject. Whenever this data changes
    * refresh should be called.
    */
interface Observer{
/*
    * Must be implemented by all observers 
    * must be implemented
    */
public void refresh();
}


/*
    * This is an Observer.
    * This implements the Observer interface and
    * guarantees that the refresh method is implemented.
    * It waits for refreshs from the subject to react.
    */
class RealObserver1 implements Observer{
//Observer name
private int id;

//reference to the subject
private Subject subject;

//Constructor
public RealObserver1(int id, Subject subject){
    this.id = id;
    this.subject = subject;
}

//This is how the Observer responds to a Notify
public void refresh(){
    System.out.println(
        "RealObserver 1 with id " + id + 
        " refreshed. Current value is " + 
        subject.getValue());
}
}

/*
    * This is a second observer class.
    * This implements the Observer interface and
    * thereby guarantees that the refresh method is implemented.
    * It waits for refreshs from the subject to react.
    */
class RealObserver2 implements Observer{
    //Observer name
private int id;

//reference to the subject
private Subject subject;

//Constructor
public RealObserver2(int id, Subject subject){
    this.id = id;
    this.subject = subject;
}

public void refresh(){
    System.out.println(
        "RealObserver 2 with id " + id + 
        " refreshed. Current value is " + 
        subject.getValue());
}
}

/*
    * In the subject class all observers are stored in
    * an array, an ArrayList or a similar data structure
    * data structure.
    * If something changes in the data (here: curValue).
    * all observers are notified.
    */
class Subject{
// Enumeration with all observers
private ArrayList observer;

//The data to be managed
private int curValue;

//Constructor
public Subject(){
    observer = new ArrayList();
    curValue = 0;
}

//Adds and notifies an observer
public void addObserver(Observer o){
    observer.add(o);
    o.refresh();
}

//remove an observer
public void removeObserver(Observer o){
    observer.remove(o);
}

//notify all obersver
public void notifyObserver(){
    for(Observer o : observer){
        o.refresh();
    }
}

//Increments the data
public void incValue(){
    curValue++;
    notifyObserver();
}

//returns the data
public int getValue(){
    return curValue;
}
}

/*
    * A subject and four observers are created.
    * After the Observer with the Subject were announced,
    * the curValue is incremented a few times.
    */
public class ObserverPattern {
public static void main(String[] args){
    //Create the subject
    Subject subject = new Subject();
    
    //Create Observers
    RealObserver1 ro1a = new RealObserver1(1,subject);
    RealObserver1 ro1b = new RealObserver1(2,subject);
    RealObserver2 ro2a = new RealObserver2(3,subject);
    RealObserver2 ro2b = new RealObserver2(4,subject);
    
    //Register the Observer
    subject.addObserver(ro1a);
    subject.addObserver(ro1b);
    subject.addObserver(ro2a);
    subject.addObserver(ro2b);
    
    //Multiple incrementing of the data
    subject.incValue();
    subject.incValue();
    subject.incValue();
}
}
                            </code>
                        </pre>
                        <p>
                            Here is an interface Observer, which is implemented by the two Observer classes RealObserver1 and RealObserver2.
                        </p>
                        <p>
                            The interface notifies all observer classes with the function refresh(), if data in the subject class have changed. This happens in that all observer classes register themselves with the subject class in an enumeration (array, list, etc.). 
                        </p>
                        <p>
                            As soon as data in the Subject class are changed, this calls the method notifyObserver(), which iterates through all Observer classes and calls their refresh() method. In this method the observer classes can then react to the data changes.  
                        </p>
                        <p>
                            Adding and removing the observer classes from the subject class is done using the addObserver(Observer) and removeObserver(Observer) methods. 
                        </p>
                        <p>
                            Using this convenient method, you can see that when data changes in a program, other parts of the program can be immediately updated and adapted to the new data.
                        </p>
                        <!-- Pros and cons section-->
                        <br>
                        <hr>
                        <br>
                        <div>
                            <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;">
                                <p class="lead text-center">
                                    <strong>Advantages:</strong>
                                    <p>
                                        <strong>State consistency:</strong>
                                        Since the observers automatically adjust their state when the subject changes, the data remains consistent in the overall system. Furthermore, the exchange of information or the coupling between the objects remains limited to the time between the logon and logoff of the observer at the subject.
                                        <br>
                                        <br>
                                        <strong>Flexibility and modularity:</strong>
                                        The system allows several different observers to observe a single subject, but also allows one observer to observe several subjects. Furthermore, classes can be both observer and subject in one.
                                        <br>
                                        <br>
                                        <strong>Reusability:</strong>
                                        The observer pattern allows subject and observer to be variable independently of each other. The subject can be reused without having to use its dependent observers and vice versa. Existing subjects can be reused when new observers are added.

                                    </p>
                                </p>
                                <br>
                            </div>
                            <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;">
                                <p class="lead text-center">
                                    <strong>Disadvantages:</strong>
                                    <p>
                                        <strong>Update cascades and cycles:</strong>
                                        In large systems with many subjects and observers, entire update cascades can quickly occur, since the observers know nothing about each other and cannot estimate the consequences of a single modification to a subject.
                                        <br>
                                        <br>
                                        <strong>Unsubscribe from Observer:</strong>
                                        It is easy to forget to unregister an observer from the subject when it is no longer needed. This can result in strange effects in cases of multiple notification and prevents automatic memory freeing (garbage collection in Java and C#), since the subject still holds a reference to an object that is no longer needed.
                                    </p>
                                </p>
                                <br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- MVC section-->
        <section id="mvc">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>MVC Pattern</h2>
                        <div class="text-center">
                            <img src="assets/umlMVC.jpg" />
                        </div>
                        <p class="lead">
                            <p><b>MVC</b> stands for <b>M</b>odel-<b>V</b>iew-<b>C</b>ontrol.</p>

                            <p>The MVC Pattern splits the program in three parts. 
                            </p>
                            <p>
                                The first part is the Model part, which includes the data respectively the access to the data. This is also the part, where the classical Object-Oriented Part of programming lies. This also includes Database access and any other form of data management.
                            </p>
                            <p>
                                Next comes the View part. This shows the Data to the user but is implemented completely independent from the Model part.
                            </p>
                            <p>
                                The third and last part is the Control part, which allows the user to control the program. The Control Part is also implemented independently of the other parts.
                            </p>
                            <p>
                                The three parts of the MVC Pattern can only communicate with each other through specifically designed access methods. The View-Class should not be able to access Objects in the Model-Class.
                            </p>
                            <p>
                                The following example shows not only the MVC Pattern but also combines it with the Observer Pattern. There two patterns are often used together because they complement each other very well. In this case the Observer-Class is used as the View-Class.
                            </p>
                        </p>
                        <pre>
                            <code class="language-java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

interface View{
    //Must be implemented by every class
    public void refresh();
}

class RealView extends JFrame implements View{
    //window ID
    private int id;
    
    //Model reference
    private Model model;
    
    //JTextField of the window
    private JTextField txt;
    
    //Konstruktor
    public RealView(int id, Model model){
        this.id = id;
        this.model = model;
        
        setTitle("View " + id);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        txt = new JTextField("");
        getContentPane().add(txt);
        
        refresh();
        
        setLocation(250, 60 * id);
        pack();
        setVisible(true);
    }
    
    /*
        * Gets executed if the Data gets changed
        */
    public void refresh(){
        txt.setText(
            "View " + id + ": " + 
            model.getValue());
    }
}

class ButtonView extends JFrame{	
    public ButtonView(Model model){		
        //sets the properties of the window
        setTitle("ButtonView");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        //adds the button to the controler class
        JButton btn = new JButton("Increment");
        btn.addActionListener(new Control(model));
        getContentPane().add(btn);
        
        //shows the window
        setLocation(100,100);
        pack();
        setVisible(true);		
    }
}

class Control implements ActionListener{
    //Model reference
    private Model model;
    
    //Konstruktor
    public Control(Model model){
        this.model = model;
    }
    
    //gets executed by button click
    public void actionPerformed(ActionEvent evt){
        model.incValue();
    }
}

class Model{
    //Array of all registered views
    private ArrayList views;
    
    //Data
    private int curValue;
    
    //Constructor
    public Model(){
        views = new ArrayList();
        curValue = 0;
    }
    
    //Adds a new view
    public void addView(View view){
        views.add(view);
        view.refresh();
    }
    
    //deletes a specific view
    public void removeView(View view){
        views.remove(view);
    }
    
    //notifies all views
    public void notifyViews(){
        for(View v : views){
            v.refresh();
        }
    }
    
    //increments the data
    public void incValue(){
        curValue++;
        notifyViews();
    }
    
    //returns the data
    public int getValue(){
        return curValue;
    }
}

public class MVCPattern {
    public static void main(String[] args){
        /*
        
            * creates the model, in which the data 
            * and the views are managed
            */
        Model model = new Model();
        
        //views to show the data
        RealView view1 = new RealView(1, model);
        RealView view2 = new RealView(2, model);
        
        //the views get registered to the model
        model.addView(view1);
        model.addView(view2);
        
        //view to control the program
        new ButtonView(model);
    }
}
                            </code>
                        </pre>

                        <!-- Pros and cons section-->
                        <br>
                        <hr>
                        <br>
                        <div>
                            <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                                <p class="lead text-center">
                                    <strong>Pros:</strong>
                                    <p>
                                        One advantage of the MVC Model is the split into logically independent classes. This allows for an agile development because there is an option the change one part without changing the other two.
                                        <br>
                                        <br>
                                        Another advantage is the possibility to show the same data in multiple views because of the shared data source. Its also possible to effortlessly implement a new view. This makes the MVC Model nearly infinitely scalable.
                                        </p>
                                </p>
                                <br>
                            </div>
                            <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                                <p class="lead text-center">
                                    <strong>Cons:</strong>
                                    <p>
                                        One disadvantage is the high complexity when accessing the same model from multiple views. This can lead to problems while trying to find problems in the program.
                                        <br>
                                        <br>
                                        There can sometimes be a problem with the efficiency of accessing the data because there is always an object in between.
                                        <br>
                                        <br>
                                        The strong connection between Model and View as well as the Model and controller can also be seen as a flaw.
                                    </p>
                                </p>
                                <br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            margin-top: 10%;
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>
        
<!-- MVVM section-->
<section id="mvvm">
    <div class="container px-4">
        <div class="row gx-4 justify-content-center">
            <div class="col-lg-8">
                <h2>MVVM Pattern</h2>
                <div class="text-center">
                    <img src="assets/uml_mvvm.png" />
                </div>
                <p class="lead">
                    <p><b>MVVM</b> steht für <b>M</b>odel-<b>V</b>iew-<b>V</b>iew<b>M</b>odel</p>

Grundidee ist die Aufteilung des Codes in einen allgemeinen, oberflächenunabhängigen Teil (das Model) und auf der anderen Seite den oberflächenspezifischen Code. Dieser kann wiederum in Code zur reinen Anzeige (die View) und Code zur Verarbeitung von Benutzereingaben und Steuerung der Oberfläche (der Controller) geteilt werden.
​
  <br>  
Die Idee von MVVM ist es, den gesamten UI-Zustand im sogenannten "ViewModel" abzubilden. Dieses ViewModel enthält also beispielsweise Felder für die aktuellen Werte von Textfeldern, Tabellen und anderen Komponenten. Außerdem werden Informationen wie "Button X ist inaktiv" ebenfalls als Boolean-Feld im ViewModel hinterlegt.
<br> Die View präsentiert lediglich den UI-Zustand des ViewModels. Wird der UI-Zustand vom Nutzer verändert, z. B. indem in einem Textfeld getippt wird, reicht die View diese Änderungen umgehend an das ViewModel weiter. Andersherum müssen aber auch Änderungen, die vom ViewModel ausgehen, umgehend von der View angezeigt werden. 
<br>View und ViewModel müssen also stets synchron gehalten werden. Wie diese Synchronisierung konkret umgesetzt wird, kommt dabei auf die Programmiersprache bzw. das Framework an.

                </p>
                <pre>
                    <code class="language-java">

                    </code>
                </pre>

                <!-- Pros and cons section-->
                <br>
                <hr>
                <br>
                <h1 class="text-center">MVC vs MVVM</h1>
                <table class="table table-bordered">
                    <thead>
                      <tr>
                        <th scope="col">MVC</th>
                        <th scope="col">MVVM</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Controller-Klasse dient als Einstiegspunkt für die Anwendung.</td>
                        <td>Die View-Klasse dient als EInstiegspunkt für die Anwendung.</td>
                      </tr>
                      <tr>
                        <td>“One to Many”-Beziehungen zwischen Controler und View. </td>
                        <td>“One to Many”-Beziehungen zwischen View und View-Model. </td>
                      </tr>
                      <tr>
                        <td>View referenziert nicht den Controller.</td>
                        <td>View referenziert die View-Model.</td>
                      </tr>
                      <tr>
                        <td>MVC ist ein altes Konzept.</td>
                        <td>MVVM ist ein relativ neues Konzept.</td>
                      </tr>
                      <tr>
                        <td>Niedrige Lesbarkeit, Wartbarkeit und schweirig für Unit-Tests. </td>
                        <td>Schwierig zu debuggen, wenn viele Data-Bindings verwendet werden.</td>
                      </tr>
                      <tr>
                        <td>MVC Model Komponenten können seperat vom Benutzer getestet werden. </td>
                        <td>Der Code ist Event-driven und leicht für Unit-Tests zugänglich. </td>
                      </tr>
                    </tbody>
                  </table>
                <div>
                    <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                        <p class="lead text-center">
                            <strong>Vorteile:</strong>
                            <p>
                                Durch diese Trennung können die Anwendungsschichten von verschiedenen Arbeitsgruppen entwickelt werden. Designer können einen Fokus auf das Benutzererlebnis und die UI legen (VIEW) und Entwickler unabhängig davon die UI- und Geschäftslogik schreibe (MODEL und VIEWMODEL). In der Regel sind keine aufwendigen UI-Tests nötig. Stattdessen genügen codebasierte Modul-Tests des ViewModel. Auch ist eine leichtere Austauschbarkeit der View z.B. nach WPF oder Windows Phone möglich. Unterstützung in WPF, Silverlight, Windows Phone und Windows Store Apps.
                            </p>
                        </p>
                        <br>
                    </div>
                    <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                        <p class="lead text-center">
                            <strong>Nachteile:</strong>
                            <p>
                                MVVM stellt einen Mehraufwand dar und ist für Anwendungen mit einfacher UI ein Overkill. Für größere Anwendungen kann das Design eines ausreichend allgemeinen ViewModel’s im Voraus schwierig sein. Außerdem führe eine schlecht verwaltete Datenbindung zu einem erheblichen Speicherbedarf der Anwendung.
                            </p>
                        </p>
                        <br>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

         <!-- Übung section-->
         <section id="exercises">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Excercises</h2>

                        <!-- Quiz section -->
                        <div class="zuordnungs-quiz" lang="de">
                            <h2 id="zuordnungs-quiz-pattern">Sort the following properties:</h2>
                            <p>Match the following words to the correct Pattern</p>
                            <table>
                                <tr>
                                    <td>Singleton</td>
                                    <td>exactly one instance</td>
                                    <td>private constructor has no function here</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                </tr>
                                <tr>
                                    <td>MVC</td>
                                    <td>three parts</td>
                                    <td>control-part</td>
                                    <td>View</td>
                                    <td>access methods</td>
                                    <td>&nbsp;</td>
                                </tr>
                                <tr>
                                    <td>Observer</td>
                                    <td>two parts</td>
                                    <td>subject class</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                </tr>
                            </table>
                        </div>
                        
                    </div>
                </div>
            </div>
        </section>
        <!-- Footer-->
        <footer class="py-5 bg-dark">
            <div class="container px-4"><p class="m-0 text-center text-white">Copyright &copy; Dennis, Florian, Michele</p></div>
            <div>Quellen: <a href="https://public.hochschule-trier.de" style="color: rgba(0, 0, 0, .0)">KLICK</a></div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
        <script src="js/prism.js"></script>
    </body>
</html>
