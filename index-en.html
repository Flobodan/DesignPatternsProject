<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>Design Patterns Introduction</title>
        <link rel="icon" type="image/x-icon" href="assets/favicon.ico" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="css/prism.css" rel="stylesheet"/>
        <link href="css/styles.css" rel="stylesheet" />
        <script type="text/javascript" src="./quiz/quiz.js"></script>
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
            <div class="container px-4">
                <a class="navbar-brand" href="#page-top">Design Patterns</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
                <div class="collapse navbar-collapse" id="navbarResponsive">
                    <ul class="navbar-nav ms-auto">
                        <li class="nav-item"><a class="nav-link" href="#introduction">Introduction</a></li>
                        <li class="nav-item"><a class="nav-link" href="#singleton">Singleton</a></li>
                        <li class="nav-item"><a class="nav-link" href="#observer">Observer</a></li>
                        <li class="nav-item"><a class="nav-link" href="#mvc">MVC</a></li>
                        <li class="nav-item"><a class="nav-link" href="#mvvm">MVVM</a></li>
                        <li class="nav-item"><a class="nav-link" href="#exercises">Exercises</a></li>
                    </ul>
                </div>
                <a class="btn btn-outline-info" href="index.html">
                    🇩🇪 German
                </a>
            </div>
        </nav>
        <!-- Header-->
        <header class="text-white" style="background: rgb(2,0,36); background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);">
            <div class="container px-4 text-center">
                <h1 class="fw-bolder">Design Patterns</h1>
                <p class="lead">Introduction in Singleton, Oberserver and MVC pattern</p>
            </div>    
        </header>




        <!-- Einführung section-->
        <section id="introduction">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h3>What are design patterns?</h3>
                        <p class="lead">
                            Design patterns offer <strong>sample solutions for recurring problems!</strong>
                            <br>
                            They designate design patterns, i.e. structures, models, templates and patterns that can be used as models in the development of stable software.
                        </p>
                    </div>
                    <div class="col-lg-8" style="padding-top: 5%;">
                        <h3>What is a pattern?</h3>
                        <p class="lead">
                            A pattern is a formal documentation in form for the model-like solution of a certain problem.
                            <br>
                            For this purpose, design patterns are not invented, but are derived from repeated application from successful practice.
                        </p>
                    </div>
                    <div class="col-lg-8" style="padding-top: 5%;">
                        <h3>Architecture patterns as a basis for modern software design!</h3>
                        <p class="lead">
                            Originally, patterns originated in the engineering field of architecture.
                            <br>
                            Even if these models relate to building architecture and urban planning, fundamental principles and insights can be transferred to disciplines such as software architectures and software development.
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- Singleton section-->
        <section class="bg-light" id="singleton">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">

                    <div class="col-lg-8">
                        <h2>Singleton</h2>
                        <div class="text-center">
                            <img src="assets/umlSingleton.png"/>
                        </div>
                        <p class="lead">
                            The Singleton design pattern is used when only one instance of an object may exist. Two types of singleton creation can be distinguished. The first possibility is a so-called lazy singleton. This means that the instance is only created when it is really needed.
                        </p>
                        <pre>
                            <code class="language-java">
public final class Singleton {

    private static Singleton instanz;
    
    private Singleton() {}
    
    public synchronized static Singleton getInstanz() {
        if(instanz==null)
            instanz = new Singleton();
        return instanz;
    }
}                           </code>
                        </pre>
                        <br>
                        <p class="lead">
                            During initialization, only the memory area for the instance is reserved. The private constructor has no function here. But by the fact that it is declared as private, it is prevented that from the outside further instances can be created. Only with the first call of "`getInstanz"' the instance is created and returned. With each further call the already created instance is returned. When using a lazy singleton, care must be taken to avoid problems with concurrency caused by multiple threads. Therefore it is necessary to declare the "`getInstance"' method as "`synchronized"'. To get around this problem one can use an Eager Singleton.
                        </p>
                        <pre>
                            <code class="language-java">
final class EagerSingleton{

    private final static EagerSingleton instanz = 
        new EagerSingleton();
    
    private EagerSingleton() {}
    
    public static EagerSingleton getInstanz() {
        return instanz;
    }
}                           </code>
                        </pre>

                    <!-- Pros and cons section-->
                    <br>
                    <hr>
                    <br>
                    <div>
                        <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;">
                            <p class="lead text-center">
                                <strong>Pros:</strong>
                            </p>
                            <p>
                                <strong>Access control:</strong> The singleton encapsulates its own creation and can thus control exactly when and how access to the singleton is allowed.
                                <br>
                                <br>
                                <strong>Clean namespace:</strong> The namespace is not overloaded with countless global variables, but provided encapsulated in a singleton.<br>
                                <br>
                                <strong>Specialization:</strong> A singleton can be derived to assign new functionality to it. Integration into existing code is simple. Which subclass is to be used can be decided dynamically at runtime.
                            </p>
                            <br>
                        </div>
                        <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;">
                            <p class="lead text-center">
                                <strong>Cons:</strong>
                            </p>
                            <p>
                                <strong>Procedural programming:</strong> The extensive use of singletons leads to a similar unfavorable condition as with global variables. This corresponds to procedural programming and has nothing to do with object orientation and encapsulation
                                A singleton can be derived to assign new functionality to it. Integration into existing code is simple. Which subclass is to be used can be decided dynamically at runtime.
                                <br>
                                <br>
                                <strong>Intransparency:</strong> 
                                Whether a class uses a singleton is not clear from its interface, but from its implementation. This is hard-coupled to the Singleton. The definition of the interface alone can no longer be relied upon, since the implementation has unspecified dependencies.
                                <br>
                                <br>
                                <strong>Clarity, maintainability and reusability suffer enormously!</strong>
                                <br>
                                When changes are made to the singleton, it is not clear which parts of the program are affected. Malfunctions can be traced back with difficulty.
                            </p>
                            <br>
                        </div>
                    </div>

                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- Observer section-->
        <section id="observer">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Observer Pattern</h2>
                        <div class="text-center">
                            <img src="assets/umlObserver.jpg" />
                        </div>
                        <p class="lead">
                            <p>
                                Das Haupteinsatzgebiet von einem Observer Pattern ist die Gestaltung von Grafischen Oberflächen.
                                Das Observer Pattern sorgt zum Beispiel dafür, dass die Elemente einer Grafische Oberfläche, die eine identische Datenquelle verwenden, sich aktualisieren, sobald sich die Quelldaten ändern.  
                                Programme, die das Observer Pattern verwenden, werden in zwei Teile aufgeteilt.
                                </p>
                                <p>
                                Einmal die Subject-Klasse, welche die Daten enthält und zum anderen die Observer-Klassen und die Observer-Schnittstelle, welche die Daten einlesen und anzeigen, ausgeben oder weiterverarbeiten. 
                                Die obere Abbildung zeigt die Struktur dieses Patterns. 
                                </p>
                                <p>
                                Im folgenden Quellcode sieht man ein Beispiel für ein Programm, welches das Observer Pattern verwendet:
                                </p>


                                <pre>
                            <code class="language-java">
import java.util.ArrayList;

/*
    * Hier wird das sogenannte Observerpattern vorgestellt.
    * Dieses dient zur Verwaltung von verschiedenen Observern,
    * welche auf die selben Daten zugreifen.
    */

/*
    * Dieses Interface stellt den anderen Observern
    * die refresh Methode zur Verfügung. Jeder Observer
    * muss diese Methode implementieren. In der Implementierung
    * der refresh Methode kann jeder Observer mit Daten des
    * Subjects arbeiten. Immer wenn diese sich ändern sollte
    * refresh aufgerufen werden.
    */
interface Observer{
/*
    * Muss von allen Observern 
    * implementiert werden
    */
public void refresh();
}


/*
    * Dies ist ein Observer.
    * Dieser implementiert die Schnittstelle Observer und
    * garantiert dadurch, dass die Refreshmethode implementiert ist.
    * Er wartet auf refreshs von dem Subject um zu reagieren.
    */
class RealObserver1 implements Observer{
//Bezeichnung des Observers
private int id;

//Referenz auf das Subject
private Subject subject;

//Konstruktor
public RealObserver1(int id, Subject subject){
    this.id = id;
    this.subject = subject;
}

//So reagiert der Observer bei einem Notify
public void refresh(){
    System.out.println(
        "RealObserver 1 with id " + id + 
        " refreshed. Current value is " + 
        subject.getValue());
}
}

/*
    * Dies ist eine zweite Observerklasse.
    * Dieser implementiert die Schnittstelle Observer und
    * garantiert dadurch, dass die Refreshmethode implementiert ist.
    * Er wartet auf refreshs von dem Subject um zu reagieren.
    */
class RealObserver2 implements Observer{
//Bezeichnung des Observers
private int id;

//Referenz auf das Subject
private Subject subject;

//Konstruktor
public RealObserver2(int id, Subject subject){
    this.id = id;
    this.subject = subject;
}

//So reagiert der Observer bei einem Notify
public void refresh(){
    System.out.println(
        "RealObserver 2 with id " + id + 
        " refreshed. Current value is " + 
        subject.getValue());
}
}

/*
    * In der Subjectklasse werden alle Observer in
    * einem Array, einer ArrayList oder einer ähnlichen
    * Datenstruktur gespeichert.
    * Falls sich etwas an den Daten ändert (hier: curValue)
    * werden alle Observer benachrichtigt.
    */
class Subject{
//Liste mit allen Observern
private ArrayList observer;

//Die zu verwaltenden Daten
private int curValue;

//Konstruktor
public Subject(){
    observer = new ArrayList();
    curValue = 0;
}

//Fügt einen Observer ein und benachrichtigt diesen
public void addObserver(Observer o){
    observer.add(o);
    o.refresh();
}

//Entfernt einen Observer
public void removeObserver(Observer o){
    observer.remove(o);
}

//Benachrichtigt alle Observer
public void notifyObserver(){
    for(Observer o : observer){
        o.refresh();
    }
}

//Inkrementiert die Daten
public void incValue(){
    curValue++;
    notifyObserver();
}

//Gibt die Daten zurück
public int getValue(){
    return curValue;
}
}

/*
    * Es werden ein Subject und vier Observer erstellt.
    * Nachdem die Observer bei dem Subject angemeldet wurden,
    * wird der curValue einige male inkrementiert.
    */
public class ObserverPattern {
public static void main(String[] args){
    //Erstellen des Subjects
    Subject subject = new Subject();
    
    //Erstellen der Observer
    RealObserver1 ro1a = new RealObserver1(1,subject);
    RealObserver1 ro1b = new RealObserver1(2,subject);
    RealObserver2 ro2a = new RealObserver2(3,subject);
    RealObserver2 ro2b = new RealObserver2(4,subject);
    
    //Anmelden der Observer
    subject.addObserver(ro1a);
    subject.addObserver(ro1b);
    subject.addObserver(ro2a);
    subject.addObserver(ro2b);
    
    //Mehrfaches inkrementieren der Daten
    subject.incValue();
    subject.incValue();
    subject.incValue();
}
}
                            </code>
                        </pre>
                        <p>
                            Dort gibt es ein Interface Observer, welches von den beiden Observer-Klassen RealObserver1 und RealObserver2 implementiert werden muss. </p>
                            <p>
                            Das Interface enthält eine Funktion refresh() mit der alle Observer-Klassen benachrichtigt werden, wenn sich Daten in der Subject-Klasse geändert haben. 
                            Dies geschieht in dem sich alle Observer-Klassen bei der Subject-Klasse in eine ArrayList (oder eine beliebige andere Struktur) eintragen. </p>
                            <p>
                            Wenn sich nun Daten ändern ruft die Subject-Klasse die Methode notifyObserver() auf, in welcher alle Observer-Klassen durchlaufen werden und deren refresh() Methode aufgerufen wird. 
                            In dieser Methode können dann die Observer-Klassen auf die Datenänderungen reagieren. </p>
                            <p>
                            Das Eintragen und Austragen der Observer-Klassen bei der Subject-Klasse geschieht über die Methoden addObserver(Observer) und removeObserver(Observer). 
                        </p>
                            <p>
                            Wie man sieht, bietet das Observer Pattern eine praktische Methode, mit welcher man dafür sorgen kann, dass bei Datenänderungen in einem Programm andere Programmteile sofort aktualisiert und an die neuen Daten angepasst werden können.</p>
                            </p>
                        <!-- Pros and cons section-->
                        <br>
                        <hr>
                        <br>
                        <div>
                            <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;">
                                <p class="lead text-center">
                                    <strong>Vorteile:</strong>
                                    <p>
                                        <strong>Zustandskonsistenz:</strong>
                                        Die Daten im Gesamtsystem bleiben konsistent, da die Observer ihren Zustand automatisch bei Änderung des Subjects anpassen. Weiterhin bleibt der Informationsaustausch bzw. die Kopplung zwischen den Objekten auf die Zeit zwischen An- und Abmelden des Observers am Subject begrenzt.
                                        <br>
                                        <br>
                                        <strong>Flexibilität und Modularität:</strong>
                                        Das System erlaubt es, dass mehrere verschiedene Observer ein einziges Subject beobachten, aber auch dass ein Observer mehrere Subjects beobachtet. Weiterhin können Klassen sowohl Observer als auch Subject in einem seien.
                                        <br>
                                        <br>
                                        <strong>Wiederverwendbarkeit:</strong>
                                        Durch das Observer Pattern lassen sich Subject und Observer unabhängig voneinander variieren. Somit kann das Subject wiederverwendet werden, ohne seine abhängigen Observer verwenden zu müssen und umgekehrt. Ebenso sind bestehende Subjects wiederverwendbar, wenn neue Observer hinzugefügt werden.

                                    </p>
                                </p>
                                <br>
                            </div>
                            <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;">
                                <p class="lead text-center">
                                    <strong>Nachteile:</strong>
                                    <p>
                                        <strong>Aktualisierungskaskaden und -zyklen:</strong>
                                        Bei umfangreichen Systemen mit vielen Subjects und Observer kann es schnell zu ganzen Aktualisierungskaskaden kommen, da die Observer nichts von einander wissen und nicht abschätzen können, welche Folgen eine einzige Modifikation an einem Subject hat.
                                        <br>
                                        <br>
                                        <strong>Abmeldung von Observer:</strong>
                                        Schnell vergisst man ein Observer beim Subject abzumelden, wenn man es nicht mehr braucht. Dies kann in Fällen von Mehrfachanmeldung (Mehrfachbenachrichtigung) merkwürdige Effekte zur Folge haben und verhindert die automatische Speicherfreisetzung (Garbage Collection in Java und C#), da das Subject immer noch eine Referenz auf ein nicht mehr gebrauchtes Objekt hält.
                                    </p>
                                </p>
                                <br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

        <!-- MVC section-->
        <section id="mvc">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>MVC Pattern</h2>
                        <div class="text-center">
                            <img src="assets/umlMVC.jpg" />
                        </div>
                        <p class="lead">
                            <p><b>MVC</b> stands for <b>M</b>odel-<b>V</b>iew-<b>C</b>ontrol.</p>

                            <p>The MVC Pattern splits the program in three parts. 
                            </p>
                            <p>
                                The first part is the Model part, which includes the data respectively the access to the data. This is also the part, where the classical Object-Oriented Part of programming lies. This also includes Database access and any other form of data management.
                            </p>
                            <p>
                                Next comes the View part. This shows the Data to the user but is implemented completely independent from the Model part.
                            </p>
                            <p>
                                The third and last part is the Control part, which allows the user to control the program. The Control Part is also implemented independently of the other parts.
                            </p>
                            <p>
                                The three parts of the MVC Pattern can only communicate with each other through specifically designed access methods. The View-Class should not be able to access Objects in the Model-Class.
                            </p>
                            <p>
                                The following example shows not only the MVC Pattern but also combines it with the Observer Pattern. There two patterns are often used together because they complement each other very well. In this case the Observer-Class is used as the View-Class.
                            </p>
                        </p>
                        <pre>
                            <code class="language-java">
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.util.ArrayList;

import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JTextField;

interface View{
    //Must be implemented by every class
    public void refresh();
}

class RealView extends JFrame implements View{
    //window ID
    private int id;
    
    //Model reference
    private Model model;
    
    //JTextField of the window
    private JTextField txt;
    
    //Konstruktor
    public RealView(int id, Model model){
        this.id = id;
        this.model = model;
        
        setTitle("View " + id);
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        txt = new JTextField("");
        getContentPane().add(txt);
        
        refresh();
        
        setLocation(250, 60 * id);
        pack();
        setVisible(true);
    }
    
    /*
        * Gets executed if the Data gets changed
        */
    public void refresh(){
        txt.setText(
            "View " + id + ": " + 
            model.getValue());
    }
}

class ButtonView extends JFrame{	
    public ButtonView(Model model){		
        //sets the properties of the window
        setTitle("ButtonView");
        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        
        //adds the button to the controler class
        JButton btn = new JButton("Increment");
        btn.addActionListener(new Control(model));
        getContentPane().add(btn);
        
        //shows the window
        setLocation(100,100);
        pack();
        setVisible(true);		
    }
}

class Control implements ActionListener{
    //Model reference
    private Model model;
    
    //Konstruktor
    public Control(Model model){
        this.model = model;
    }
    
    //gets executed by button click
    public void actionPerformed(ActionEvent evt){
        model.incValue();
    }
}

class Model{
    //Array of all registered views
    private ArrayList views;
    
    //Data
    private int curValue;
    
    //Constructor
    public Model(){
        views = new ArrayList();
        curValue = 0;
    }
    
    //Adds a new view
    public void addView(View view){
        views.add(view);
        view.refresh();
    }
    
    //deletes a specific view
    public void removeView(View view){
        views.remove(view);
    }
    
    //notifies all views
    public void notifyViews(){
        for(View v : views){
            v.refresh();
        }
    }
    
    //increments the data
    public void incValue(){
        curValue++;
        notifyViews();
    }
    
    //returns the data
    public int getValue(){
        return curValue;
    }
}

public class MVCPattern {
    public static void main(String[] args){
        /*
        
            * creates the model, in which the data 
            * and the views are managed
            */
        Model model = new Model();
        
        //views to show the data
        RealView view1 = new RealView(1, model);
        RealView view2 = new RealView(2, model);
        
        //the views get registered to the model
        model.addView(view1);
        model.addView(view2);
        
        //view to control the program
        new ButtonView(model);
    }
}
                            </code>
                        </pre>

                        <!-- Pros and cons section-->
                        <br>
                        <hr>
                        <br>
                        <div>
                            <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                                <p class="lead text-center">
                                    <strong>Pros:</strong>
                                    <p>
                                        One advantage of the MVC Model is the split into logically independent classes. This allows for an agile development because there is an option the change one part without changing the other two.
                                        <br>
                                        <br>
                                        Another advantage is the possibility to show the same data in multiple views because of the shared data source. Its also possible to effortlessly implement a new view. This makes the MVC Model nearly infinitely scalable.
                                        </p>
                                </p>
                                <br>
                            </div>
                            <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                                <p class="lead text-center">
                                    <strong>Cons:</strong>
                                    <p>
                                        One disadvantage is the high complexity when accessing the same model from multiple views. This can lead to problems while trying to find problems in the program.
                                        <br>
                                        <br>
                                        There can sometimes be a problem with the efficiency of accessing the data because there is always an object in between.
                                        <br>
                                        <br>
                                        The strong connection between Model and View as well as the Model and controller can also be seen as a flaw.
                                    </p>
                                </p>
                                <br>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Spacer -->
        <div style="
            margin-top: 10%;
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>
        
<!-- MVVM section-->
<section id="mvvm">
    <div class="container px-4">
        <div class="row gx-4 justify-content-center">
            <div class="col-lg-8">
                <h2>MVVM Pattern</h2>
                <div class="text-center">
                    <img src="assets/uml_mvvm.png" />
                </div>
                <p class="lead">
                    <p><b>MVVM</b> steht für <b>M</b>odel-<b>V</b>iew-<b>V</b>iew<b>M</b>odel</p>

Grundidee ist die Aufteilung des Codes in einen allgemeinen, oberflächenunabhängigen Teil (das Model) und auf der anderen Seite den oberflächenspezifischen Code. Dieser kann wiederum in Code zur reinen Anzeige (die View) und Code zur Verarbeitung von Benutzereingaben und Steuerung der Oberfläche (der Controller) geteilt werden.
​
  <br>  
Die Idee von MVVM ist es, den gesamten UI-Zustand im sogenannten "ViewModel" abzubilden. Dieses ViewModel enthält also beispielsweise Felder für die aktuellen Werte von Textfeldern, Tabellen und anderen Komponenten. Außerdem werden Informationen wie "Button X ist inaktiv" ebenfalls als Boolean-Feld im ViewModel hinterlegt.
<br> Die View präsentiert lediglich den UI-Zustand des ViewModels. Wird der UI-Zustand vom Nutzer verändert, z. B. indem in einem Textfeld getippt wird, reicht die View diese Änderungen umgehend an das ViewModel weiter. Andersherum müssen aber auch Änderungen, die vom ViewModel ausgehen, umgehend von der View angezeigt werden. 
<br>View und ViewModel müssen also stets synchron gehalten werden. Wie diese Synchronisierung konkret umgesetzt wird, kommt dabei auf die Programmiersprache bzw. das Framework an.

                </p>
                <pre>
                    <code class="language-java">

                    </code>
                </pre>

                <!-- Pros and cons section-->
                <br>
                <hr>
                <br>
                <h1 class="text-center">MVC vs MVVM</h1>
                <table class="table table-bordered">
                    <thead>
                      <tr>
                        <th scope="col">MVC</th>
                        <th scope="col">MVVM</th>
                      </tr>
                    </thead>
                    <tbody>
                      <tr>
                        <td>Controller-Klasse dient als Einstiegspunkt für die Anwendung.</td>
                        <td>Die View-Klasse dient als EInstiegspunkt für die Anwendung.</td>
                      </tr>
                      <tr>
                        <td>“One to Many”-Beziehungen zwischen Controler und View. </td>
                        <td>“One to Many”-Beziehungen zwischen View und View-Model. </td>
                      </tr>
                      <tr>
                        <td>View referenziert nicht den Controller.</td>
                        <td>View referenziert die View-Model.</td>
                      </tr>
                      <tr>
                        <td>MVC ist ein altes Konzept.</td>
                        <td>MVVM ist ein relativ neues Konzept.</td>
                      </tr>
                      <tr>
                        <td>Niedrige Lesbarkeit, Wartbarkeit und schweirig für Unit-Tests. </td>
                        <td>Schwierig zu debuggen, wenn viele Data-Bindings verwendet werden.</td>
                      </tr>
                      <tr>
                        <td>MVC Model Komponenten können seperat vom Benutzer getestet werden. </td>
                        <td>Der Code ist Event-driven und leicht für Unit-Tests zugänglich. </td>
                      </tr>
                    </tbody>
                  </table>
                <div>
                    <div class="row card bg-success bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                        <p class="lead text-center">
                            <strong>Vorteile:</strong>
                            <p>
                                Durch diese Trennung können die Anwendungsschichten von verschiedenen Arbeitsgruppen entwickelt werden. Designer können einen Fokus auf das Benutzererlebnis und die UI legen (VIEW) und Entwickler unabhängig davon die UI- und Geschäftslogik schreibe (MODEL und VIEWMODEL). In der Regel sind keine aufwendigen UI-Tests nötig. Stattdessen genügen codebasierte Modul-Tests des ViewModel. Auch ist eine leichtere Austauschbarkeit der View z.B. nach WPF oder Windows Phone möglich. Unterstützung in WPF, Silverlight, Windows Phone und Windows Store Apps.
                            </p>
                        </p>
                        <br>
                    </div>
                    <div class="row card bg-danger bg-opacity-25" style="margin: 2% 0 2% 0;padding-left: 10px;">
                        <p class="lead text-center">
                            <strong>Nachteile:</strong>
                            <p>
                                MVVM stellt einen Mehraufwand dar und ist für Anwendungen mit einfacher UI ein Overkill. Für größere Anwendungen kann das Design eines ausreichend allgemeinen ViewModel’s im Voraus schwierig sein. Außerdem führe eine schlecht verwaltete Datenbindung zu einem erheblichen Speicherbedarf der Anwendung.
                            </p>
                        </p>
                        <br>
                    </div>
                </div>
            </div>
        </div>
    </div>
</section>

        <!-- Spacer -->
        <div style="
            background: rgb(2,0,36);
            background: linear-gradient(90deg, rgba(2,0,36,1) 0%, rgba(9,9,121,1) 35%, rgba(0,212,255,1) 100%);
            height: 65px;
        "></div>

         <!-- Übung section-->
         <section id="exercises">
            <div class="container px-4">
                <div class="row gx-4 justify-content-center">
                    <div class="col-lg-8">
                        <h2>Exercises</h2>

                        <!-- Quiz section -->
                        <div class="zuordnungs-quiz" lang="de">
                            <h2 id="zuordnungs-quiz-pattern">Ordne die Eigenschaften zu.</h2>
                            <p>Ordnen Sie folgende Begriffe/Dinge einander zu, indem Sie die grünen Felder mit der Maus verschieben!</p>
                            <table>
                                <tr>
                                    <td>Singleton</td>
                                    <td>genau eine Instanz</td>
                                    <td>private Konstruktor hat hier keine Funktion</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                </tr>
                                <tr>
                                    <td>MVC</td>
                                    <td>drei Teile</td>
                                    <td>Control-Teil</td>
                                    <td>View</td>
                                    <td>Zugriffsmethoden</td>
                                    <td>&nbsp;</td>
                                </tr>
                                <tr>
                                    <td>Observer</td>
                                    <td>Zwei Teile</td>
                                    <td>Subject-Klasse</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                    <td>&nbsp;</td>
                                </tr>
                            </table>
                        </div>
                        
                    </div>
                </div>
            </div>
        </section>
        <!-- Footer-->
        <footer class="py-5 bg-dark">
            <div class="container px-4"><p class="m-0 text-center text-white">Copyright &copy; Dennis, Florian, Michele</p></div>
            <div>Quellen: <a href="https://public.hochschule-trier.de" style="color: rgba(0, 0, 0, .0)">KLICK</a></div>
        </footer>
        <!-- Bootstrap core JS-->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.0/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
        <script src="js/prism.js"></script>
    </body>
</html>
